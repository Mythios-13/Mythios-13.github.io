<!DOCTYPE html>
<html>
<head>
  <title>Video Last Frame Extractor</title>
</head>
<body>
  <input type="file" id="videoInput" accept="video/mp4">
  <button id="extractBtn">Extract & Download</button>
  <script type="module">
    import * as MP4Box from 'https://cdn.jsdelivr.net/npm/mp4box@latest/dist/mp4box.all.js';

    function buildAVCDescription(avcC) {
      let size = 7; // Fixed header: version(1) + profile(1) + compat(1) + level(1) + lengthSize(1) + numSPS(1) + numPPS(1)
      avcC.SPS.forEach(sps => size += 2 + sps.length);
      avcC.PPS.forEach(pps => size += 2 + pps.length);

      const buffer = new Uint8Array(size);
      let pos = 0;

      buffer[pos++] = 1; // configurationVersion
      buffer[pos++] = avcC.AVCProfileIndication;
      buffer[pos++] = avcC.profile_compatibility;
      buffer[pos++] = avcC.AVCLevelIndication;
      buffer[pos++] = 0xFC | avcC.lengthSizeMinusOne; // reserved(6)='111111'b + lengthSizeMinusOne(2)
      buffer[pos++] = 0xE0 | avcC.SPS.length; // reserved(3)='111'b + numOfSequenceParameterSets(5)

      avcC.SPS.forEach(sps => {
        buffer[pos++] = (sps.length >> 8) & 0xFF;
        buffer[pos++] = sps.length & 0xFF;
        buffer.set(new Uint8Array(sps.data), pos);
        pos += sps.length;
      });

      buffer[pos++] = avcC.PPS.length; // numOfPictureParameterSets (u8)

      avcC.PPS.forEach(pps => {
        buffer[pos++] = (pps.length >> 8) & 0xFF;
        buffer[pos++] = pps.length & 0xFF;
        buffer.set(new Uint8Array(pps.data), pos);
        pos += pps.length;
      });

      return buffer;
    }

    async function extractLastFrame() {
      const file = document.getElementById('videoInput').files[0];
      if (!file) return alert('Select a video');

      const arrayBuffer = await file.arrayBuffer();
      const mp4boxFile = MP4Box.createFile();

      let readyResolve;
      const readyPromise = new Promise(resolve => readyResolve = resolve);
      let fileInfo = null;

      mp4boxFile.onReady = function(info) {
        console.log('MP4 parsed, info:', info);
        fileInfo = info;
        readyResolve();
      };

      mp4boxFile.onError = function(e) {
        console.error('MP4 parsing error:', e);
        alert('MP4 parsing error: ' + e);
      };

      // Append in chunks for better parsing reliability
      const chunkSize = 65536;
      let offset = 0;
      while (offset < arrayBuffer.byteLength) {
        const chunkLength = Math.min(chunkSize, arrayBuffer.byteLength - offset);
        const chunk = arrayBuffer.slice(offset, offset + chunkLength);
        chunk.fileStart = offset;
        mp4boxFile.appendBuffer(chunk);
        console.log('Appended chunk at offset', offset, 'size', chunkLength);
        offset += chunkLength;
      }
      mp4boxFile.flush();
      console.log('Flush called, total size appended:', offset);

      // Wait for parsing to be ready (onReady may fire during or after appends)
      await readyPromise;

      if (!fileInfo) return alert('Failed to parse MP4 info');

      const videoTrackInfo = fileInfo.videoTracks && fileInfo.videoTracks[0] || fileInfo.tracks.find(t => t.type === 'Video' || t.codec.startsWith('avc'));
      if (!videoTrackInfo) {
        console.log('No video track found');
        return alert('No video track found');
      }

      const videoTrackId = videoTrackInfo.id;
      console.log('Found video track ID:', videoTrackId, 'with codec:', videoTrackInfo.codec);

      const track = mp4boxFile.getTrackById(videoTrackId);
      const avcC = track.mdia.minf.stbl.stsd.entries[0].avcC;
      const description = buildAVCDescription(avcC);

      const config = {
        codec: videoTrackInfo.codec,
        description
      };
      console.log('Decoder config:', config);

      const decoder = new VideoDecoder({
        output: handleFrame,
        error: e => console.error('Decoder error:', e)
      });
      await decoder.configure(config);
      console.log('Decoder configured');

      let lastFrame = null;
      function handleFrame(frame) {
        console.log('Frame decoded:', frame.timestamp);
        if (lastFrame) lastFrame.close();
        lastFrame = frame;
      }

      let allSamples = [];
      const totalSamples = videoTrackInfo.nb_samples;
      console.log('Expecting total samples:', totalSamples);

      const samplesPromise = new Promise(resolve => {
        mp4boxFile.onSamples = function(id, user, samples) {
          console.log('Samples batch received:', samples.length);
          allSamples.push(...samples);
          console.log('Total samples so far:', allSamples.length);

          // Free memory for processed samples
          mp4boxFile.releaseUsedSamples(id, allSamples.length);

          if (allSamples.length >= totalSamples) {
            console.log('All samples received');
            const timescale = videoTrackInfo.timescale;
            const chunks = allSamples.map(sample => new EncodedVideoChunk({
              type: sample.is_sync ? 'key' : 'delta',
              timestamp: sample.cts * 1000000 / timescale,
              duration: sample.duration * 1000000 / timescale,
              data: sample.data
            }));

            console.log('Decoding', chunks.length, 'chunks');
            chunks.forEach(chunk => decoder.decode(chunk));
            decoder.flush().then(() => {
              console.log('Flush complete');
              if (!lastFrame) {
                console.log('No frames decoded');
                return alert('Failed to decode any frames');
              }

              console.log('Last frame ready:', lastFrame.displayWidth, 'x', lastFrame.displayHeight);

              // Draw to canvas
              const canvas = document.createElement('canvas');
              canvas.width = lastFrame.displayWidth;
              canvas.height = lastFrame.displayHeight;
              canvas.style.border = '1px solid black'; // Basic styling for visibility
              canvas.style.marginTop = '10px';
              const ctx = canvas.getContext('2d');
              ctx.drawImage(lastFrame, 0, 0);
              lastFrame.close();

              // Remove any previous canvas
              const oldCanvas = document.querySelector('canvas');
              if (oldCanvas) oldCanvas.remove();

              // Append to body for visualization
              document.body.appendChild(canvas);

              // Download (still included)
              canvas.toBlob(blob => {
                if (!blob) {
                  console.log('Blob creation failed');
                  return alert('Failed to create image blob');
                }
                console.log('Blob created, size:', blob.size);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'last-frame.png';
                a.click();
                URL.revokeObjectURL(url);
                console.log('Download triggered');
              }, 'image/png');
              resolve(); // Done
            }).catch(e => console.error('Flush error:', e));
          }
        };
      });

      // Extract all samples (in one batch since total is small)
      mp4boxFile.setExtractionOptions(videoTrackId, null, { nbSamples: totalSamples });
      mp4boxFile.start();
      console.log('Extraction started');

      // Wait for extraction and decoding to complete
      await samplesPromise;
      console.log('Extraction complete');
    }

    document.getElementById('extractBtn').addEventListener('click', extractLastFrame);
  </script>
</body>
</html>